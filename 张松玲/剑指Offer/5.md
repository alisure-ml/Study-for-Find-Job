## 优化时间和空间效率


### 时间效率

> 编程习惯、循环和递归、算法功底、态度与激情


**题目39：数组中出现次数超过一半的数字**

1. 先排序，再找中位数：`O(nlogn)`。
2. 基于二分函数的时间复杂度为`O(n)`的算法（需要修改数组）：选择一个数字，小于在左边，大于等于在右边。直到选择的数字是中位数。
3. 根据数组特点找出时间复杂度为`O(n)`的算法（不修改数组，不相同的两个数字抵消，剩下的就是需要的）：保存当前数字并设置次数为1，当下一个数字和保存的数字相等时，次数+1，否则次数-1，当次数为0时，保存下一个数字并设置次数为1。


**题目40：最小的K个数**

> 考虑输入的数据量有多大、能否一次性载入内存、是否允许修改输入数据的顺序。

1. 先排序，再找前K个数：`O(nlogn)`。
2. 基于二分函数的时间复杂度为`O(n)`的算法（需要修改数组）：二分，位置K-1在哪边就对哪边进行二分，直到选择的数字在位置K-1处。
3. 时间复杂度为`O(nlogk)`的算法（适合处理海量数据）：最大堆保存最小的K个数。


**题目41：数据流中的中位数**

|数据结构|插入的时间复杂度|得到中位数的时间复杂度|算法|
|:---:|:---:|:---:|:---:|
|没有排序的数组|O(1)|O(n)|插入随便，得中位数时采用二分法|
|排序的数组|O(n)|O(1)|插入时排序|
|排序的链表|O(n)|O(1)|插入时排序|
|二叉搜索树|平均O(logn),最差O(n)|平均O(logn),最差O(n)|需要在二叉树节点中添加一个表示子树节点数目的字段|
|AVL树|O(logn)|O(1)|将平衡因子改为左右子树节点数目之差|
|最大堆和最小堆|O(logn)|O(1)|。。|

1. 最大堆（存小值）和最小堆（存大值）：
    * 保证数据平均分配到两个堆中，数目之差不能超过1。
    当两个堆中的总数目是偶数时插入最小堆，否则插入最大堆。
    * 保证最大堆中的所有数据都小于最小堆中的数据。
    当两个堆中的总数目是偶数时，需要插入到最小堆，如果此时新的数据比最大堆中最大的数字要小，则把最大堆中最大的数字拿出来插入到最小堆，然后把当前数据插入到最大堆即可。
    当两个堆中的总数目是奇数时，情况类似。


**题目42：连续子数组的最大和**

1. 举例分析数组的规律
    * 两个变量：一个累加的子数组和（小于等于0时要重新累加），一个最大的子数组和（记录最大的值）。

2. 应用动态规划法（定义出`f(i)`并找到`f(i)`和`f(i-1)`的关系即可）
    * 用函数`f(i)`表示以第i个数字结尾的子数组的最大和


**题目43：1-n整数中1出现的次数**

1. 递归：划分成两段。对于第二段，计算最高位和非最高位。对第一段进行递归。


**题目44：数字序列中某一位的数字**

> 注意题目中是从0开始。

1. 先确定`i`位的数量并确定位数，判断要求的第n位数是否在其中。若在其中，则计算在`i`位数的第几个，从而求出对应的数字。


**题目45：把数组排成最小的数**

1. 对所有数字进行排序：对`m`和`n`进行排序：比较`mn`和`nm`。


**题目46：把数字翻译成字符串：有多少中不同的翻译方法**

1. 动态规划：`f(n)`表示前`n`个数字不同翻译的数目，其和`f(n-1)`和`f(n-2)`(当`n-1`和`n`位上数字大于等于10且小于等于25时)有关系。


**题目47：礼物的最大价值**

> 动态规划的表可以优化成一维

1. 动态规划：定义`f(i,j)`为跳到位置`(i,j)`时的最大价值，其和`f(i-1,j)`和`f(i,j-1)`有关


**题目48：最长不含重复字符的子字符串**

> 用数组记录上次出现在字符串中的位置。

1. 动态规划：定义`f(i)`为以第i个字符为结尾的不包含重复字符的子字符串的最长长度。
2. 如果第i个字符之前没有出现过，则`f(i)=f(i-1)+1`。
3. 如果第i个字符之前出现过：先计算第i个字符和它上次出现在字符串中位置的距离d。如果d小于等于`f(i-1)`，此时`f(i)=d`。如果d大于`f(i-1)`，则`f(i)=f(i-1)+1`。



### 时间效率与空间效率的平衡

> 探讨是`以时间换空间`还是`以空间换时间`


**题目49：丑数**

1. 保存当前已经找到的丑数，寻找下一个丑数。


**题目50：第一个只出现一次的字符**

1. 哈希表统计次数，时间复杂度`O(n)`

**题目50-1：从第一个字符串中删除在第二个字符串中出现过的所有字符**

1. 哈希表统计第二个字符串，然后扫描第一个字符串看是否有对应统计。

**题目50-2：删除字符串中所有重复出现的字符**

1. 哈希表统计字符串，当第二次出现时直接删除。

**题目50-3：判断变位词**

1. 统计第一个字符串（统计到某个字符时，哈希表对应位置+1），然后统计第二个字符串（统计到某个字符时，哈希表对应位置-1）。


**题目50-4：字符流中第一个只出现一次的字符**

1. 哈希表进行统计：用字符的ASCII码作为键值，字符对应的位置作为值。初始值为-1，当第二次出现时值为-2。取最小的值大于等于0的值的键值即可。


**题目51：数组中的逆序对**

1. 先把数组分隔成子数组，统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目，
在统计的过程中，需要对数组进行排序。


**题目52：两个链表的第一个公共节点**

1. 用两个辅助栈：先把所有的节点压入相应的栈中，然后进行比较，直到找到最后一个相同的节点。

2. 先统计两个链表各自的长度。然后长的先走，之后比较两个链上的当前节点，直到节点相同。


