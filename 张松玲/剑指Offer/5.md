## 优化时间和空间效率


### 时间效率

> 编程习惯、循环和递归、算法功底、态度与激情


**题目39：数组中出现次数超过一半的数字**

1. 先排序，再找中位数：`O(nlogn)`。
2. 基于二分函数的时间复杂度为`O(n)`的算法（需要修改数组）：选择一个数字，小于在左边，大于等于在右边。直到选择的数字是中位数。
3. 根据数组特点找出时间复杂度为`O(n)`的算法（不修改数组，不相同的两个数字抵消，剩下的就是需要的）：保存当前数字并设置次数为1，当下一个数字和保存的数字相等时，次数+1，否则次数-1，当次数为0时，保存下一个数字并设置次数为1。


**题目40：最小的K个数**

> 考虑输入的数据量有多大、能否一次性载入内存、是否允许修改输入数据的顺序。

1. 先排序，再找前K个数：`O(nlogn)`。
2. 基于二分函数的时间复杂度为`O(n)`的算法（需要修改数组）：二分，位置K-1在哪边就对哪边进行二分，直到选择的数字在位置K-1处。
3. 时间复杂度为`O(nlogk)`的算法（适合处理海量数据）：最大堆保存最小的K个数。


**题目41：数据流中的中位数**

|数据结构|插入的时间复杂度|得到中位数的时间复杂度|算法|
|:---:|:---:|:---:|:---:|
|没有排序的数组|O(1)|O(n)|插入随便，得中位数时采用二分法|
|排序的数组|O(n)|O(1)|插入时排序|
|排序的链表|O(n)|O(1)|插入时排序|
|二叉搜索树|平均O(logn),最差O(n)|平均O(logn),最差O(n)|需要在二叉树节点中添加一个表示子树节点数目的字段|
|AVL树|O(logn)|O(1)|将平衡因子改为左右子树节点数目之差|
|最大堆和最小堆|O(logn)|O(1)|。。|

1. 最大堆（存小值）和最小堆（存大值）：
    * 保证数据平均分配到两个堆中，数目之差不能超过1。
    当两个堆中的总数目是偶数时插入最小堆，否则插入最大堆。
    * 保证最大堆中的所有数据都小于最小堆中的数据。
    当两个堆中的总数目是偶数时，需要插入到最小堆，如果此时新的数据比最大堆中最大的数字要小，则把最大堆中最大的数字拿出来插入到最小堆，然后把当前数据插入到最大堆即可。
    当两个堆中的总数目是奇数时，情况类似。


**题目42：连续子数组的最大和**

1. 举例分析数组的规律
    * 两个变量：一个累加的子数组和（小于等于0时要重新累加），一个最大的子数组和（记录最大的值）。

2. 应用动态规划法（定义出`f(i)`并找到`f(i)`和`f(i-1)`的关系即可）
    * 用函数`f(i)`表示以第i个数字结尾的子数组的最大和


**题目43：1-n整数中1出现的次数**

1. 递归：划分成两段。对于第二段，计算最高位和非最高位。对第一段进行递归。


**题目44：数字序列中某一位的数字**

> 注意题目中是从0开始。

1. 先确定`i`位的数量并确定位数，判断要求的第n位数是否在其中。若在其中，则计算在`i`位数的第几个，从而求出对应的数字。


**题目45：把数组排成最小的数**

1. 对所有数字进行排序：对`m`和`n`进行排序：比较`mn`和`nm`。


**题目46：把数字翻译成字符串：有多少中不同的翻译方法**

1. 动态规划：`f(n)`表示前`n`个数字不同翻译的数目，其和`f(n-1)`和`f(n-2)`(当`n-1`和`n`位上数字大于等于10且小于等于25时)有关系。


**题目47：礼物的最大价值**

> 动态规划的表可以优化成一维

1. 动态规划：定义`f(i,j)`为跳到位置`(i,j)`时的最大价值，其和`f(i-1,j)`和`f(i,j-1)`有关



