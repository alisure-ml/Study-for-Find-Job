## 解决面试题的思路


### 画图让抽象问题形象化


> 不但可以辅助思考，还可以清晰地解释思路。


**题目27：二叉树得镜像**

> 画图、特殊输入、递归终止条件

> 树的遍历：递归，循环需要用`栈`结构，层次遍历需要用`队列`结构。

1. 前序遍历树的每个节点，如果遍历到的节点有子节点，就交换它的两个子节点。


**题目28：对称的二叉树**

> 画图、特殊输入

1. 前序遍历和对称前序遍历（节点的空指针也遍历）


**题目29：顺时针打印矩阵**

> 一圈一圈的打印

1. 一圈一圈地打印，每一圈分为4步：需要判断是否有该步。
    * 第一步：从左到右打印
    * 第二步：从上到下打印
    * 第三步：从右到左打印
    * 第四步：从下到上打印



### 举例让抽象问题具体化

> 试着用一两个具体的例子模拟操作的过程。


**题目30：包含min函数的栈**

1. 每次把当前最小的元素压入另一个栈中。


**题目31：栈的压入、弹出序列**

1. 判断栈顶是否为弹出序列的当前值：若是，则弹出栈且弹出序列后移；若不是，则当下一个值压入栈。


**题目32：从上到下打印二叉树**

> 广度遍历用队列，深度遍历用栈

1. `队列`：每打印一个节点时，若该节点有子节点，则把该节点的子节点放到一个队列的末尾。


**题目32-2：分行从上到下打印二叉树**

1. `队列`：增加两个变量，一个表示当前层中还没有打印的节点数，另一个表示下一层节点的数目。


**题目32-3：之字形打印二叉树**

1. 打印某一层时，把下一层的子节点保存到相应的栈里。如果当前是奇数层，则先保存左子节点再保存右子节点；如果当前是偶数层，则先保存右子节点再保存左子节点。


**题目33：二叉搜索树的后序遍历序列**

1. 最后一个数字`a`将遍历序列划分为两部分，第一部分中的数字全部大于`a`，第二部分中的数字全部小于`a`。若满足进行递归判断每一部分。


**题目34：二叉树中和为某一值的路径**

1. 当用前序遍历的方式访问到某一节点时，把该节点添加到路径上，并累加该节点的值。
如果该节点为叶节点，并且路径上的值当好等于输入的整数，则当前路径符合要求。
如果不是叶节点，则继续访问它的左右子节点。
当前节点访问结束后，在路径上删除当前节点并减去当前节点的值。



### 分解让复杂问题简单化

> 把大问题分解成若干个简单的小问题，然后再逐个解决这些小问题。

> 分治法，通常可以用递归实现。


**题目35：复杂链表的复制**

> 拆分成多个步骤

1. 根据原始链表的每个节点N创建对应的节点N'，把N'链接在N的后面。
2. 设置复制的节点的`m_pSibling`。
3. 把这个长链表拆分成两个链表：把奇数位置的节点用`m_pNext`链接起来就是原始链表，把偶数位置的节点用`m_pNext`链接起来就是复制出来的链表。


**题目36：二叉搜索树与双向链表**

1. 中序遍历：把树分成三部分：根节点、左子树、右子树，然后把左子树中最大的节点、根节点、右子树中最小的节点链接起来。


**题目37：序列化二叉树**

1. 序列化：中序遍历，空子节点用符号表示。
2. 反序列化：中序遍历，构造当前节点，然后左子节点、右子节点。


**题目38：字符串的排列**

1. 求所有可能出现在第一个位置的字符。
2. 固定第一个字符，求后面所有字符的排列。


**题目38-2：字符串的组合**

1. 将`n`个字符分成两部分：第一个字符和其余的所有字符。
2. 拆分成两个子问题：
    * 若组合里包含第一个字符，求`n-1`个字符中长度为`m-1`的组合
    * 若组合里不包含第一个字符，求`n-1`个字符中长度为`m`的组合。


**题目38-3：8个数字-正方体**

1. 先求8个数字的所有排列，然后判断是否符合要求。


**题目38-4:8皇后不在同一行、同一列、同一对角线**

1. 首先定义一个大小为8的一维数组，然后进行0-7的全排列。最后再判断每个序列是否满足不在同一对角线。


