## 高质量代码


### 代码的完整性

> `代码的规范性`：`清晰的书写`、`清晰的布局`、`合理的命名`

> 在写代码之前形成清晰的思路并能把思路用编程语言清楚地书写出来。



### 代码的完整性


> `基本功能`、`输入边界值`、`不合法输入`。通常可以从`功能测试`、`边界测试`和`负面测试`这三个方面设计测试用例，以保证代码的完整性。

> `边界测试`：循环的边界条件、递归终止的边界值等等

> `负面测试`：考虑各种错误输入

> 在听到面试官的题目后，要尽快分析出可能存在哪些非法的输入，并和面试官讨论如何处理。


**题目16：数值的整数次方**

1. 对`0`和`负数`进行分析


**题目17：打印从1到最大的n位数**

> 大数问题：数据表示方式

1. 字符串：在字符串上进行加和进位操作
2. 递归：函数中调用10次函数


**题目18：删除链表的节点**

> 注意删除节点为链表`尾部`或`头部`的节点、只有一个节点的链表。

1. 首先得到要删除的节点的下一个节点，用下一个节点的内容覆盖删除的节点的内容，再把下一个节点删除。


**题目18-1：删除排序链表中重复的节点**

> 重复节点位于头部、中间、尾部。


**题目19：正则表达式匹配**

> 思维要全面，考虑各种情况。

1. 递归调用


**题目20：表示数值的字符串**

> 思维要全面，考虑各种情况：功能性输入、特殊输入。

1. 理解数字的3个组成部分，然后判断所属情况是否符合要求。


**题目21：调整数组顺序使奇数位于偶数前面**

1. 两个指针从两头扫描，满足交换条件后进行交换。


### 代码的鲁棒性

> 程序能够判断输入是否合乎规范要求，并对不符合要求的输入予以合理的处理。

> 容错性使鲁棒性的一个重要体现。

> 防御性编程：预见再什么地方可能会出现问题，并为这些可能出现的问题制定处理方式。

> 在程序函数的入口处添加代码以验证用户输入是否符合要求。

> 要格外地注意函数的输入参数、题目的条件。


**题目22：链表中倒数第k个节点**

> 注意：`特殊输入`。

1. 两个指针：一个先走，然后两个一起走。


**题目22-1：链表的中间节点**

1. 两个指针：一个走两步，一个走一步。


**题目23：链表中环的入口节点**

> 把问题分解为多个步骤。

1. 先确定是否包含环：两个指针，一个每次走一步，一个每次走两步。如果两个指针相遇，则说明有环；如果快的指针走到链表尾部，则说明没有环。
2. 再找到环的节点数量：当慢指针追上快指针时，说明该节点在环上，因此可以计数直到再次到该节点即得到环的的节点数量。
3. 最后找到环的入口：两个指针，一个先走环节点数步后，两个再同时走，直到两个节点相遇，则该节点即为环的入口节点。


**题目24：反转链表**

> 提前想好测试用例（功能测试、特殊输入测试）：空指针、一个节点、多个节点

1. 定义三个指针：当前节点、前一个节点、后一个节点

> 也可以用递归实现

```C++
ListNode* ReverseList(ListNode* pHead){
    ListNode* pReversedHead = nullptr;
    ListNode* pNode = pHead;
    ListNode* pPrev = nullptr;
    while(pNode != nullptr){
        ListNode* pNext = pNode->m_pNext;

        if(pNext == nullptr)
            pReversedHead = pNode;
        pNode->m_pNext = pPrev;

        pPrev = pNode;
        pNode = pNext;
    }
    return pReversedHead
}
```


```C++
ListNode* ReverseList(ListNode* pNode, ListNode* pPrev){
    ListNode* pNext = pNode->m_pNext;
    if(pNext == nullptr)
        return pNode;

    pNode->m_pNext = pPrev;

    pPrev = pNode;
    pNode = pNext;

    return ReverseList(pNode, pPrev)
}
```


**题目25：合并两个排序的链表**

> 解题时想清楚过程，要想到特殊用例

1. 可以递归实现


**题目26：树的子结构**

> 时刻想着指针是否为`空`。

1. 先查找与根节点的值一样的节点R
2. 然后判断树A中以R为根节点的子树和树B是否具有相同的结构

> 上面两步都是用递归，第1步中调用第2步的递归



