## 数据结构

> 六种：数组，字符串，链表，树，栈和队列

* 数组、字符串：连续存储
* 链表、树：出现频率高，链表涉及到大量指针，容易出错
* 栈：与递归紧密相关
* 队列：与广度优先遍历紧密相关


### 数组

> 占据一块连续的内存并顺序存储数据。需要预先指定数组的大小用于分配内存，因此效率不高。

* 由于数组的内存是连续的，可以在`O(1)`时间内读写任何元素：可以实现简单的哈希表。

* 为了解决数组空间效率不高的问题，设计了多种动态数组：首先为数组开辟较小的空间，然后往数组里添加数据。当数据的数目超过数组的容量时，再重新分配一块更大的空间，把之前的数据复制到新的数组中，再把之前的内存释放。

**题目2：找出数组中重复的数字**

1. 先排序，后扫描：`O(nlogn)`
2. 哈希表（Key-Value）：`O(n)`时间，`O(n)`空间
3. 交换数字，直到发现重复数字：`O(n)`时间，`O(1)`空间


**题目3：不修改数组找出重复的数字**

1. 创建一个辅助数组：`O(n)`时间，`O(n)`空间
2. 二分法寻找重复数字：`O(nlogn)`时间，`O(1)`空间

**题目4：二维数组中查找**

1. 从具体的问题入手，通过分析简单且具体的例子，来寻找普遍的规律。
2. 从右上角或左下角开始查找，使得每次都能判断都能删除一行或一列。


### 字符串

> 字符串是由若干字符组成的序列。C/C++中每个字符串都以`\0`作为结尾，所以长度为`字符数量+1`。

**题目5：替换空格**

> 1. 在原来的字符串上修改，会覆盖该字符后面的字符
> 2. 创建新的字符串，需要分配新的内存

1. 从前到后替换：依次移动空格后的字符，`O(n*n)`时间
2. 从后到前替换：首先遍历字符串，统计空格数量计算出总长度，从后往前移动并替换字符串，`O(n)`时间

> 扩展题目：两个排序数组合并为一个排序数组（从后向前）。


### 链表

> 链表很重要，是一种动态数据结构，有链表的创建、插入节点、删除节点等操作。
当新建链表时，无须知道链表的长度，当插入节点时需要为新节点分配内存，然后调整指针。
每添加一个节点分配一次内存，没有闲置的内存，因此链表的空间效率较高。

> 由于链表的内存不是一次性分配的，因此无法保证链表的内存连续。
当查找第i个节点时，我们需要从头节点开始，沿着指针遍历链表，因此时间效率为`O(n)`。


**题目6：从尾到头打印链表**

1. 栈：遍历时先将值保存在栈中，遍历结束后输出栈
2. 递归：先访问节点，再输出


### 树

> 除根节点外每个节点只有一个父节点，根节点没有父节点；
除叶节点外所有节点都有一个或多个子节点，叶节点没有子节点。

> 二叉树：每个节点最多只能有两个子节点。

> 二叉搜索树：左子节点总是小于或等于根节点，右子节点总是大于或等于根节点；可以在`O(logn)`时间内找到节点。

> 堆：最大堆和最小堆，可用于快速查找最大值或最小值。

> 红黑树：把树中的节点定义为红黑两种颜色，并确保从根节点到叶节点的最长路径的长度不超过最短路径的两倍。

> 遍历（`递归`和`循环`）：
`前序遍历`：根左右；
`中序遍历`：左根右；
`后序遍历`：左右根；
`宽度优先遍历`：按层次遍历；


**题目7：重建二叉树**

1. 递归：根据前序遍历序列确定根节点，在中序遍历序列中划分左右子树，然后以递归的方式遍历左右子树。


**题目8：二叉树的下一个节点**

> 画出二叉树的结构图，通过具体的例子找规律。

1. 如果该节点有右子树：则为右子树的最左子节点；
2. 如果该节点没有右子树，且节点是父节点的左子节点：则为父节点；
3. 如果该节点没有右子树，且节点是父节点的右子节点：沿着父节点一直向上遍历，直到找到一个是它父节点的左子节点的节点，则为该左子节点的父节点。


### 栈和队列

> 栈：先进后出

> 队列：先进先出

**题目9：用两个栈实现队列**

> 通过具体的例子分析。

1. 入队列时，始终在栈1中入；出队列时，当栈2中有值时直接出栈，当栈2中没有值时，先将栈1中的所有值放入栈2后再出栈。

**题目9扩展：用两个队列实现一个栈**

> 通过具体的例子分析

1. 入栈时，在有值的队列中入；出栈时，将有值的队列中的值出队列，并将之在另一个队列中入队列，最后一个出队列的值即为出栈的值。



## 算法和数据操作

> 很多算法都可以用递归和循环两种不同的方式实现。

> 通常基于递归的实现方法代码会比较简洁，但性能不如基于循环的实现方法。

> 通常排序和查找是考察的重点，应该掌握二分查找、归并排序和快速排序，并能够随时正确、完整地写出代码。

> 回溯法：

> 动态规划：适用于可以分为多个子问题。

> 贪婪算法：一直采用某个特殊的选择将一定能得到最优解。

> 位运算：与、或、异或、左移和右移。


### 递归和循环

> 如果我们需要重复地多次计算相同的问题，则通常可以选择用递归或者循环两种不同的方法。

> 递归是在一个函数的内部调用这个函数本身。
循环是通过设置计算的初始值及终止条件，在一个范围内重复运算。

> 递归虽然简洁，但是其效率不如循环：递归由于是函数调用自身，而函数调用是有时间和空间的消耗的，每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址及临时变量，而且往栈里压入数据和弹出数据都需要时间。

> 递归中有很多计算都是重复的。递归的本质是把一个问题分解成两个或多个小问题，如果多个小问题存在相互重叠的部分，就存在重复的计算。

> 递归还有可能导致调用栈溢出：每个进程的栈容量是有限的。


**题目10：斐波那契数列**

1. 递归算法：重复计算量大
2. 循环算法：避免重复
3. 数学公式法：矩阵的乘方


**题目10-2：青蛙跳台阶问题(1阶或2阶)**

1. 转化为斐波那契数列：`f(n)=f(n-1)+f(n-2)`


**题目10-3：青蛙跳台阶问题(1阶、2阶、...或n阶)**

1. 数学归纳法：`f(n)=2^(n-1)`


**题目10-4：2x1的小矩形横着或竖着覆盖2xn的大矩形**

1. 转化为斐波那契数列：`f(n)=f(n-1)+f(n-2)`


### 查找和排序

> 查找：顺序查找、二分查找、哈希表查找和二叉树查找。

> 已排序的数组中查找，都可以尝试二分查找算法。

> 哈希表和二叉排序树的重点在于考查数据结构。

> 哈希表的优点是能够在`O(1)`的时间内查找某一元素，缺点是需要额外的空间来实现哈希表。


> 排序：需要比较插入排序、冒泡排序、归并排序、快速排序等不同算法的优劣。
能够从额外空间消耗、平均时间复杂度和最差时间复杂度等方面比较它们的优缺点。

> 快速排序：先在数组中选择一个数字，然后把数组中的数字分为两部分，比选择的数字小的数字移到数组的左边，比选择的数字大的数字移到数组的右边。最后，用递归的思路分别对每次选中的数字的左右两边排序。

> 面试排序算法时，要多问面试官，把未明确的条件了解清楚。


**题目11：旋转数组的最小数字**

> 考查思维的全面性：注意旋转数组的特例，要进行分析。

> 题目不理解要进行沟通。

1. 用二分法进行查找：`O(logn)`时间


### 回溯法

> 暴力法的升级版。适合由多个步骤组成的问题，并且每个步骤都有多个选项。
当我们在某一步选择了其中一个选项时，就进入下一步，然后又面临新的选项。直至到达最终的状态。

> 如果把问题的解空间看出一棵树，则回溯法就类似于树的深度遍历，在遍历到叶节点时判断该条路径是否满足条件。


**题目12：矩阵中的路径**

> 抽象出问题：假如矩阵中某个格子的字符为`c`,并且这个格子对应路径上的第`i`个字符。
如果路径上的第`i`个字符是`c`，那么到相邻的格子寻找路径上的第`i+1`个字符。
如果路径上的第`i`个字符不是`c`，那么这个格子不可能处在路径上的第`i`个字符。

> 矩阵中的每一个值都作为起点进行搜索，并建立一个布尔访问矩阵

1. 递归：函数中调用四个方向进行递归
2. 栈：利用栈进行搜索，将四个方向的值入栈


**题目13：机器人的运动范围**

> 抽象出问题：当准备进入坐标为`(i,j)`的格子时，检查是否可以进入。如果可以，再判断是否可以进入4个相邻的格子。

1. 递归：函数中调用四个方向进行递归
2. 栈：利用栈进行搜索，将四个方向的值入栈


### 动态规划与贪婪算法

**判断是否可以用动态规划的条件：**

1. 是否能分解为子问题：如果面试题是求一个问题的最优解，而且该问题能够分解成若干个子问题，并且子问题之间还有重复的更小的子问题，就可以考虑用动态规划来解决。
2. 是否最优解依赖各个子问题的最优解：如果分解后的小问题存在最优解，且把小问题的最优解组合起来能够得到整个问题的最优解。
3. 是否有重复的更小的子问题：把大问题分解成若干个小问题后，这些小问题之间是否有相互重叠的更小的子问题。

> 为了避免重复计算子问题，我们可以用从下往上的顺序先计算小问题的最优解存储下来，再以此为基础求取大问题的最优解。

> 从上往下分析问题，从下往上求解问题：在应用动态规划解决问题的时候，我们总是从解决最小问题开始，把已经解决的子问题的最优解存储下来，并把子问题的最优解组合起来逐步解决大的问题。

**贪婪算法：**

1. 当我们应用贪婪算法解决问题的时候，每一步都可以做出一个贪婪的选择，基于这个选择，我们确定能够得到最优解。

> 当应用贪婪选择使，要明白为什么这样的贪婪选择能得到最优解。


**题目14：剪绳子**

> 符合动态规划的条件。

1. 动态规划：从下往上计算`f(n)=max(f(i)*f(n-i))`。
使用两个`for`循环，第一个表示从下到上，并保存结果。第二个是求最大值。`O(n*n)`时间和`O(n)`空间。
2. 贪婪算法：当`n>=5`时，尽可能多的剪长度为3的绳子；当`n=4`时，剪成两段长度为2的绳子。`O(1)`时间。


### 位运算

> 位运算：把数字用二进制表示之后，对每一位上0或者1的运算。

> 五种位运算：与、或、异或、左移、右移。

> 左移：左边舍弃，右边补0

> 右移：右边舍弃，左边（无符号补0，有符号正数补0有符号负数补1）


**题目15：二进制中1的个数**

> 注意负数和0

1. 首先把n和1做与运算，判断n的最低位是不是1，接着把1左移一位得到2，再和n做与运算，判断n的次低位是不是1,,,反复左移即可。
2. 把n和n-1做位与运算：`(n-1)&n`。


**题目15-1：一条语句判断一个整数是不是2的整数次方**

1. 一个整数如果是2的整数次方，则二进制表示中有且只有一位是1，其它位是0：`(n-1)&n==0`


**题目15-2：两个整数m和n，计算需要改变m的二进制中的多少位能得到n**

1. 先求这两个数的异或，再统计异或结果中1的位数。



